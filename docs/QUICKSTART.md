# 快速开始指南

## 🚀 5分钟快速体验

### 步骤 1: 安装依赖

```bash
pip install -r requirements.txt
```

### 步骤 2: 启动应用

```bash
python gradio_residual_tft_app.py
```

应用会自动在浏览器打开 http://localhost:7860

### 步骤 3: 创建示例数据

1. 点击 **"📂 数据加载"** tab
2. 点击 **"🎲 创建示例数据"** 按钮
3. 等待数据生成完成

### 步骤 4: 训练SST模型

1. 切换到 **"🎯 SST模型训练"** tab
2. 在 **"边界信号"** 中选择: `boundary_1` 到 `boundary_10` (全选10个)
3. 在 **"目标信号"** 中选择: `target_1` 到 `target_5` (全选5个)
4. 保持默认参数
5. 点击 **"▶️ 开始训练SST"**
6. 等待训练完成（约2-3分钟）

### 步骤 5: 提取残差

1. 切换到 **"🔬 残差提取"** tab
2. 点击 **"🔄 刷新"** 按钮
3. 在下拉框中选择刚训练的SST模型
4. 保持默认参数（未来预测长度=10）
5. 点击 **"🔬 提取残差"**
6. 查看残差可视化

### 步骤 6: 训练Stage2模型

1. 切换到 **"🚀 Stage2 Boost训练"** tab
2. 点击 **"🔄 刷新"** 按钮
3. 选择刚提取的残差数据
4. 保持默认参数
5. 点击 **"🚀 开始训练Stage2"**
6. 等待训练完成（约2-3分钟）

### 步骤 7: 生成综合推理模型

1. 切换到 **"🎯 综合推理模型"** tab
2. 点击 **"🔄 刷新"** 按钮
3. 选择基础SST模型和Stage2模型
4. R²阈值保持默认 0.4
5. 点击 **"🎯 生成综合模型"**
6. 查看每个信号的R²分析和性能对比

### 步骤 8: 二次推理比较

1. 切换到 **"📊 二次推理比较"** tab
2. 点击 **"🔄 刷新"** 按钮
3. 选择刚生成的综合模型
4. Index范围: 起始=0, 结束=1000
5. 点击 **"📊 执行比较"**
6. 查看性能对比可视化

**🎉 恭喜！你已经完成了完整的工作流程！**

---

## 📊 使用自己的数据

### 数据格式要求

CSV文件格式：
```csv
boundary_1,boundary_2,...,target_1,target_2,...
1.23,4.56,...,7.89,0.12,...
2.34,5.67,...,8.90,1.23,...
...
```

**要求**:
- 第一行为列名
- 无缺失值
- 数值型数据
- 建议至少10000行

### 完整工作流程

```
数据准备
  ↓
SST模型训练（30-60分钟）
  ↓
残差提取（5分钟）
  ↓
Stage2训练（30-60分钟）
  ↓
生成综合模型（2分钟）
  ↓
性能验证（5分钟）
```

---

## 🔧 常见问题

### Q1: 训练太慢怎么办？

**A**: 
- 减小 `epochs` 到 50-80
- 增大 `batch_size` 到 128
- 减小 `d_model` 到 64

### Q2: 显存不足？

**A**:
- 减小 `batch_size` 到 16
- 减小 `d_model` 到 64
- 使用CPU训练（自动切换）

### Q3: 综合模型没有改进？

**A**:
- 检查R²阈值，尝试降低到 0.3
- 确保Stage2训练充分
- 检查残差数据质量

### Q4: 如何保存和加载模型？

**A**:
- 所有模型自动保存在 `saved_models/` 目录
- 推理配置文件: `*_inference.json`
- 在"残差提取"tab上传配置文件即可加载

### Q5: Sundial功能如何使用？

**A**:
- 当前版本为框架，完整功能待v2.0
- 可以提前训练综合模型，后续直接使用

---

## 💡 优化建议

### 1. 参数调优

**SST模型**:
```python
# 小数据集 (<50K)
d_model=64, nhead=4, num_layers=2

# 中等数据集 (50K-200K)
d_model=128, nhead=8, num_layers=3  # 推荐

# 大数据集 (>200K)
d_model=256, nhead=16, num_layers=4
```

**Stage2模型**:
```python
# 通常比SST稍简单
d_model=64-128
nhead=4-8
num_layers=2-3
```

### 2. R²阈值选择

| 数据特征 | 推荐阈值 |
|---------|---------|
| 高噪声 | 0.3 |
| 中等质量 | 0.4 ⭐ |
| 高质量 | 0.5 |
| 极高质量 | 0.6+ |

### 3. 数据分割

```python
# 训练 / 验证 / 测试
# 推荐: 70% / 15% / 15%

test_size = 0.15
val_size = 0.15
# train = 70%
```

---

## 📈 性能预期

### 示例数据集结果

基于10000个样本的示例数据：

| 阶段 | MAE | RMSE | R² | 训练时间 |
|------|-----|------|-----|---------|
| SST | 0.15 | 0.22 | 0.75 | ~3分钟 |
| + Stage2 | 0.12 | 0.18 | 0.85 | +3分钟 |
| **提升** | **20%** | **18%** | **+13%** | **总6分钟** |

### 真实数据集结果

基于LEAP工业数据集（625K样本）：

| 阶段 | MAE | RMSE | R² | 训练时间 |
|------|-----|------|-----|---------|
| SST | 0.08 | 0.12 | 0.82 | ~30分钟 |
| + Stage2 | 0.065 | 0.10 | 0.88 | +30分钟 |
| **提升** | **19%** | **17%** | **+7%** | **总60分钟** |

---

## 🎯 下一步

### 进阶使用

1. **模型集成**
   - 训练多个Stage2模型
   - 使用不同R²阈值
   - 选择最优组合

2. **超参数优化**
   - 网格搜索最优参数
   - 使用Optuna自动调优

3. **产品化部署**
   - 导出ONNX模型
   - API服务封装
   - 批量推理优化

### 参考资料

- [Transformer论文](https://arxiv.org/abs/1706.03762)
- [PyTorch文档](https://pytorch.org/docs/)
- [Gradio文档](https://gradio.app/docs/)

---

## 🆘 获取帮助

遇到问题？

1. 查看 **README.md** 详细文档
2. 查看 **UPDATE_NOTES.md** 了解所有功能
3. 检查控制台输出的错误信息
4. 提交Issue并附上：
   - 错误信息
   - 数据规模
   - 配置参数

---

**祝你使用愉快！** 🎉
